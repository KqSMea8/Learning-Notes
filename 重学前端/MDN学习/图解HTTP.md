#了解Web及网络基础
- TCP/IP协议族
    + 协议protocol
    + 协议中存在各式各样的内容，把互联网相关联的协议集合起来总称为TCP/IP
    + TCP/IP的分层管理
        * 应用层：决定了向用户提供应用服务时通信的服务
            - FTP文件传输协议
            - DNS域名系统
            - HTTP超文本传输协议
        * 传输层：提供出于网络连接中的两台计算机之间的 **数据传输**
            - TCP传输控制协议
            - UDP用户数据报协议
        * 网络层（网络互连层）：处理在网络上流动的数据包。数据包是网络传输的最小单位。规定了到达对方计算机的 **传输路线**，并把数据包传送给对方。
            - IP网络协议
        * 数据链路层（链路层，网络接口层）:处理连接网络的硬件部分
            - 操作系统
            - 设备驱动
            - NIC网络适配器，网卡
            - 光纤
    + IP、TCP、DNS——TCP/IP协议族中与HTTP密不可分的三个协议
        * IP网络协议——负责传输
            - 位于网络层
            - 作用是把各种数据传送给对方
            - 确保确实传送到了对方那里，需要满足各类条件，其中两个重要的条件是IP地址和MAC地址
                + IP地址：指明了节点被分配到的地址
                + MAC(media access control媒介访问控制)地址：指网卡所属的固定地址
                + IP地址可以和MAC地址配对。IP地址可变换，MAC地址基本上不会更改
                + IP间的通信依赖MAC地址
                + 使用ARP协议凭借MAC地址进行通信
                    * ARP(address resolution protocal)地址解析协议
                    * 根据通信方的IP地址就可以反查出对应的MAC地址
                    * 在进行多台计算机和网络设备的中转时，ARP会利用下一站中转设备的MAC地址来搜索下一个中转目标
            - 没有人能够全面掌握互联网中的传输状况
                + routing路由选择机制：在到达通信目标前的中转过程中，计算机和网络设备只能获悉很粗略的传输路线
        * TCP传输控制协议——确保传输可靠性
            - 位于传输层
            - 提供可靠的字节流服务(byte stream server)：为了方便传输，将大块数据分割成以报文段segment为单位的数据包进行管理。
            - 确保数据能准确可靠地到达目标
                + 三次握手three-way handshaking策略
                    * 首先，发送端发送一个带SYN标志的数据包给对方
                    * 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息
                    * 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束
                + TCP的标志
                    * SYN-synchronize同步
                    * ACK-acknowlegdement确认
            - 除了三次握手，TCP协议还有其他手段来保证通信的可靠性
        * DNS服务——负责域名解析
            - 位于应用层
            - 提供域名到IP地址之间的解析服务：提供通过域名查找IP地址，或逆向从IP地址反查域名的服务
            - 计算机可以被赋予IP地址(计算机更擅长处理数字)，也可以被赋予域名和主机名(人类的记忆习惯)
                + 域名用于公网，主机名用于局域网
- URI和URL
    + URL统一资源定位符：使用Web浏览器等访问Web页面时需要输入的网页地址
        * URL表示资源的地点(互联网上所处的位置)，是URI的子集
    + URI统一资源标识符
        * Uniform规定统一的格式可方便处理多种不同类型的资源
        * Resource资源的定义是“可标识的任何对象”
        * Identifier表示可标识的东西
        * URI就是由某个协议方案(访问资源所使用的协议类型名称)表示的资源的定位标识符。
        * 采用HTTP协议时，协议方案就是http。还有类似的ftp、mailto、telnet、file
        * 绝对URI的格式：(协议方案名://登陆信息(认证)@服务器地址：服务器端口号/带层次的文件路径？查询字符串#片段标识符)[http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1]
            - 协议方案名：获取访问资源时要指定协议类型，不区分大小写，也可以指定数据(:data)或脚本程序(:javascript)的方案名
            - 登陆信息(认证)：可选项，用户名和密码作为从服务器端获取资源时的认证
            - 服务器地址：使用绝对URI必须指定待访问的服务器地址，地址可以是
                + hackr.js这种DNS可解析的名称
                + 192.168.1.1这种IPv4地址名
                + [0:0:0:0:0:0:0:1]这种IPv6地址名
            - 服务器端口号：可选项，服务器连接的网络端口号
            - 带层次的文件路径：指定服务器上的文件路径来定位特指的资源
            - 查询字符串：可选项，针对已指定的文件路径内的资源，来通过查询字符串传入任意参数
            - 片段标识符：可选项，可标记出已获取资源中的子资源(文档内的某个位置)
- 补充
    + RFC(request for comments)征求修正意见书
        * 用来指定HTTP协议技术标准的文档，是互联网的设计文档，不按照RFC标准可能导致无法通信。
        * 并不是所有的APP都符合RFC，他们有自己的一套“标准”

#简单的HTTP协议
- HTTP协议：用于客户端和服务端之间的通信，能够明确区分哪一端是哪一端
    + 客户端：请求访问文本或图像等资源的一端称为客户端
    + 服务端：提供资源响应的一端称为服务端
- 请求和响应
    + 请求报文：请求行(请求方法、请求URI、协议版本)、可选的请求首部字段、内容实体 
    + 响应保本：状态行(协议版本、状态码、用以解释状态码的原因短语)、可选的响应首部字段、主体
- HTTP是 __无状态__协议
    + 协议对于发送过的请求和响应 __不做持久化处理__
    + 为了快速的处理大量事务，确保协议的可伸缩性,减少服务器的CPU及内存消耗
    + 为了实现期望的保持状态功能引入了Cookie技术
- 请求URI：定位资源
    + URI为完整的请求URI
    + 在首部字段Host中写明网络域名或IP地址
    + 以*代替请求URI
        * OPTIONS * HTTP/1.1   查询HTTP服务器端支持的HTTP方法种类
- 请求方法：告知服务器意图
    + GET：__获取资源(我想访问某个资源)__
        * 用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容
        * 
    + POST：__传输实体主体(我要告诉你某条信息)__
        * POST的主要目的不是获取响应的主体内容，而是传输实体的主体
        * 指定URI接收传输的主体的处理结果
    + PUT：__传输文件(我要传给你某份文件)__
        * 在请求报文的主体中包含文件内容，然后保存到请求URI指定位置
        * REST(REpresentational State Transfer)表征状态转移 标准
        * HTTP/1.1的PUT方法自身不带校验机制，存在安全问题，一般Web网站不使用PUT，可配合Web APP的验证机制或采用REST标准的架构设计的Web网站
    + HEAD：__获得报文首部(把某相关信息告诉我)__
        * 与GET一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等
    + DELETE：__删除文件(把某份文件删除掉)__
        * 与PUT相反的方法，按请求URI删除指定资源
        * 同PUT一样不带校验机制
    + OPTIONS：__询问支持的方法(URI指定的资源支持哪些方法)__HTTP/1.0不支持
        * OPTIONS * HTTP/1.1
        * Allow：GET,POST,HEAD,OPTIONS
    + TRACE：__追踪路径(追踪发出请求之后会发生什么)__HTTP/1.0不支持
        * 让Web服务器端将之前的请求通信环回给客户端，确认连接过程中发生的一系列操作
        * 首部字段Max-Forwadrs:每经过一个服务器端就将该数值减1，减为0时停止传输，最后接收到请求的服务器端返回状态200 OK的响应
        * 不怎么常用，容易引发XST(Cross-Site Tracing,跨站攻击)
        * 从代理服务器路由中转时请求可能被篡改，客户端通过TRACE方法查询发送出去的请求是如何被加工修改/篡改的
    + CONNECT：__要求用隧道协议连接代理(通过隧道进行传输)__HTTP/1.0不支持
        * CONEECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。
        * 使用SSL(Secure Socket Layer安全套接层)和TLS(Transport Layer Security传输层安全)协议把通信内容加密后经网络隧道传输
        * 格式：CONNECT 代理服务器名：端口号 HTTP版本
        * 粒子：CONNECT proxy.hackr.jp:8080 HTTP/1.1
    + LINK：建立和资源之间的联系，HTTP/1.1废弃
    + UNLINK：断开连接关系，HTTP/1.1废弃
- HTTP协议的 __持久连接__
    + 只要任意一端没有明确提出断开连接，则保持TCP连接状态
    + 好处：减轻服务器端的负载，减少了TCP连接的重复建立和断开造成的额外开销，Web页面的显示速度提高了
    + 在HTTP/1.1中，所有连接默认都是持久连接的
- HTTP协议的 __管线化__
    + 同时并行发送多个请求，而不需要一个接一个地等待响应
    + 管线化技术比持久连接还要快，请求数越多，时间差就越明显
- Cookie
    + 通过在请求和响应报文中写入Cookie信息来控制客户端的状态
    + 有Cookie之后
        * 客户端发起请求，服务器生成Cookie保存请求并记住是哪个客户端发送的
        * Cookie根据服务器发送的响应报文内的一个叫Set-Cookie首部字段信息，通知客户端保存Cookie
        * 再下一次客户端发送请求时，客户端会添加Cookie后发送
        * 服务端发现有发送Cookie，会检查Cookie是从哪一个客户端发送的链接请求，服务器对比之前保存的请求记录，得到之前的状态
    + 没有Cookie信息的状态
        * 请求报文：首部字段内无Cookie相关信息
        * 响应报文：<Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT>
    + 存有Cookie信息的状态
        * 请求报文：Cookie: sid=1342077140226724
    + 补充：SID安全标识符

#HTTP报文内的HTTP信息
- HTTP报文message:用于HTTP协议交互的信息
    + 通常分为报文首部和报文主体，由空行(CR+LF)来划分。不过不一定要有报文主体
    + 
- 请求报文和响应报文的结构
    + 请求报文
        * 请求行、各种首部字段(请求首部字段、通用首部字段、实体首部字段、其他)、报文主体
        * 请求行：包含用于请求的方法，请求URI和HTTP版本
    + 响应报文
        * 状态行、各种首部字段(响应首部字段、通用首部字段、实体首部字段、其他)、报文主体
        * 状态行：包含表明响应结果的状态码，原因短语和HTTP版本
    + 其他首部字段
        * 可能包含HTTP的RFC里未定义的首部，如Cookie
- 编码操作：(传输过程中进行编码)提升传输速率
    + 报文主体与实体主体差异
        * __报文__是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输；__实体__是传输过程中被传输的补充项(有效载荷数据)
        * 通常报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容才发生变化，导致与报文主体产生差异 
    + 内容编码：压缩传输
        * 指明应用在实体主体上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码
        * 服务端将实体主体压缩，响应给客户端解码复原
        * 常用的内容编码
            - gzip：GNU zip
            - compress：UNIX系统的标准压缩
            - deflate：zlib
            - identity：不进行编码
    + 分块传输编码：分割发送 Chunked Transfer Coding
        * 将实体主体分成多块。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会用“0并换行”来标记
        * 服务端将实体主体分块，响应给客户端解码复原
        * HTTP/1.1中的传输编码机制：只定义作用于分块传输编码中，在通信时按某种编码方式传输
- 多部分对象集合Multipart:发送多种数据
    + MIME(Multipurpose Internet Mail Extensions，多用途因特网邮件扩展)
        * 允许邮件处理文本、图片、视频等多个不同类型的数据
        * MIME扩展中会使用一种称为 __多部分对象集合__的方法，来容纳多分不同类型的数据
    + HTTP协议中也采纳了类似MIME扩展中的 __多部分对象集合__方法，通常是资源上传时使用
        * multipart/form-data
            - 在Web表单文件上传时使用
        * multipart/byteranges
            - 状态码206(Partial Content部分内容)响应报文包含了多个范围的内容时使用
        * Content-type:Multipart;boundary=实体
        * 起始行：--实体；结束：--实体--
- 范围请求：获取部分内容
    + 能从之前下载中断处恢复下载，指定范围发送的请求交范围请求range request
    + 首部字段Range指定资源的byte范围
        * 5001-10000字节，Range:bytes=5001-10000
        * 5001字节以后的全部，Range:bytes=5001-
        * 从一开始到3000字节和5000到7000的 __多重范围__，Range:bytes=-3000, 5000-7000
    + 针对范围请求，响应会返回状态码为206 partial content的响应报文
    + 针对多重范围，会用到上述的Content-type:multipart/byteranges
    + 若服务器无法响应范围请求，则返回200 OK和完整实体主体
- 内容协商:返回最合适的内容
    + 会以响应资源的语言、字符集、编码方式等作为判断的基准，提供给客户端最为合适的资源
    + 判断的基准为包含在请求报文中的某些字段
        * Accept
        * Accept-Charset
        * Accept-Encoding
        * Accept-Language
        * Content-Language
    + 内容协商技术有三种类型
        * 服务器驱动协商
            - 原理：服务器以请求的首部字段为参考，在服务端自动处理
            - 问题：以浏览器发送的信息作为判定依据，不一定能筛选出最优内容
        * 客户端驱动协商
            - 原理：用户从浏览器显示的可选项列表中手动选择
            - 优势：可以利用JS脚本在Web页面上自动选择，比如按操作系统或浏览器类型自行切换PC版或移动版
        * 透明协商
            - 上述两种类型的结合体，两端各自进行内容协商

#返回结果的HTTP状态码
- 响应类别：状态码中的第一位数字
    + 1XX：Informational信息类状态码-接受的请求正在处理
    + 2XX：Success成功状态码-请求正常处理完毕
    + 3XX：Redirection重定向状态码-需要进行附加操作以完成请求
    + 4XX：Client Error客户端错误状态码-服务器无法处理请求
    + 5XX：Server Error服务端错误状态码-服务器处理请求出错
    + 记录在RFC2616上的状态码40种，加上WebDAV(RFC4918、5842)和附加HTTP状态码(RFC6585)拓展，数量达60余种。常用的有14种
- 2XX成功-表明请求被正常处理
    + 200 OK
    + 204 No Content
    + 206 Partical Content
- 3XX重定向-浏览器需要执行某些特殊的处理以正确处理请求
    + 301 Moved Permanently
        * 永久性重定向
    + 302 Found
        * 临时性重定向
    + 303 See Other
        * 功能与302类似，但明确表示客户端应当采用GET方法获取资源
    + 304 Not Modified
        * 表明客户端发送附带条件的请求时，服务器允许请求访问，但未满足条件
        * If-...
        * 304返回不包含任何主体，且与重定向没有关系
    + 307 Temporary Redirect
        * 临时重定向
        * 307遵照浏览器标准，不会从POST变为GET
    + 补充：301、302、303返回时，几乎所有浏览器把POST改成GET，并删除请求报文主体，之后请求再次发送。301、302标准是禁止将POST改为GET，但实际使用时大家都会这么做。
- 4XX客户端错误-表明客户端是发生错误的原因所在
    + 400 Bad Request
        * 请求报文中存在语法错误
        * 浏览器会像对待200 OK一样对待他
    + 401 Unauthorized
        * 发送的请求需要有通过HTTP认证的认证信息
        * 若之前已进行过一次请求，则表示用户认证失败
    + 403 Forbidden
        * 对请求资源的访问被服务器拒绝
    + 404 Not Found
        * 可能服务器拒绝请求且不想说明理由
- 5XX服务器错误-服务器本身发生错误
    + 500 Internal Server Error
        * 服务器执行请求是发生错误
    + 503 Service Unavailable
        * 服务器暂时处于超负荷或正在停机维护，现在无法处理请求
- 补充：状态码和状况不一致是经常遇到的，有些程序内部错误依然返回200 OK

#与HTTP协作的Web服务器
- 用单台虚拟主机实现多个域名
- 通信数据转发程序：代理、网关、隧道
    + 代理：中间人，是一种有 __转发功能__的 __应用程序__
        * 接受客户端发送的请求后转发给其他服务器。
        * 代理不改变请求URI，会直接发送给前方持有资源的目标(源)服务器
        * 每次通过代理服务器转发请求或响应时,会追加写入Via首部信息以标记出经过的主机
        * 使用代理的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的
        * 代理有多种使用方法：是否使用缓存，是否会修改报文
            - 缓存代理
                + 再次请求相同资源时，就不必从源服务器那获取资源
            - 透明代理
                + 不对经过的报文做任何加工
    + 网关：伪装者，是转发其他服务器通信数据的 __服务器__
        * 网关能使通信线路上的服务器提供非HTTP协议服务
        * 提高安全性，客户端与网关之间的通信线路可以加密
    + 隧道：快递员，在相隔甚远的客户端与服务器两者之间进行 __中转__，并保持双方通信连接的 __应用程序__
        * 确保客户端与服务端能够进行安全通信
        * 隧道本身不会去解析HTTP请求，在双方断开连接后隧道也消失
        * CONNECT方法
- 缓存：保存资源
    + 本地磁盘内保存的资源副本，节省通信流量和通信时间
    + 缓存服务器是代理服务器的一种，归类在缓存代理类型中
    + 缓存的有效期限
    + 客户端缓存：浏览器缓存，临时网络文件

#HTTP首部
#确保Web安全的HTTPS
- HTTP的缺点
    + 明文通信，内容可能被窃听
        * TCP/IP是可能被窃听的网络
        * 加密处理防窃听
            - 通信的加密(通道加密)：SSL、TLS
            - 内容的加密：前提是双端的加密解密机制
    + 不验证通信方的身份，因此可能遭遇伪装
        * 任何人都可以发起请求，隐患如下
            - Web服务器伪装
            - 客户端伪装
            - 是否有访问权限
            - 请求来自何方，出自谁手
            - 接收无意义的请求，DoS攻击
        * 查明对手的证书
            - SSL：不仅提供加密处理，还使用一种手段--证书，用于确定通信方的真实意图
            - 客户端完成个人身份的确认也可以持有证书，用于Web网站的认证环节
    + 无法证明报文的完整性，所以报文可能被篡改(完整性：信息的准确性)
        * 接收到的内容可能有误
            - MITM中间人攻击
        * 如何防止篡改
            - MD5、SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法
            - 提供文件下载服务的Web网站会提供相应的以PGP(pretty good privacy完美隐私)创建的数字签名及MD5算法生成的散列值。PGP是用来创建文件的数字签名，MD5是由单向函数生成的散列值
- HTTPS = HTTP + 加密 + 认证 +完整性的保护
    + HTTPS
        * HTTP Secure
    + 身披SSL外壳的HTTP
        * HTTPS并非是应用层的新协议，HTTP通信接口部分用SSL和TLS协议代替
        * SSL是应用最为广泛的网络安全技术，可以和应用层的其他协议搭配
    + SSL采用公开密钥加密技术：相互交换密钥
        * Public-key cryptography公开密钥加密：加密算法是公开的，而密钥却是保密的
        * 共享密钥加密的困境
            - Common key crypto system，加密解密通用一个密钥，也称为 **对称密钥**加密symmetrickey algorithm
        * 使用两把密钥的公开密钥加密
            - 公开密钥加密使用 **非对称的密钥**，一把叫做私有密钥，一把叫做公开密钥
            - 使用公开密钥进行加密，使用私有密钥进行解密，公开密钥可以转交任何人
        * HTTPS采用混合加密机制
            - 公开密钥加密处理速度比共享密钥加密要慢
            - **交换密钥环节**使用公开密钥加密，之后建立通信交换报文阶段使用共享密钥加密
            - 把用共享密钥加密发送报文同时携带的密钥交换过程进行公开密钥加密
    + 证书：证明公开密钥正确性
        * 怎么证明公开密钥是真的公开密钥？公开密钥证书
        * 接到 **证书**的客户端可使用数字证书认证机构的公开密钥对证书上的 **数字签名**进行验证，一旦通过验证，客户端便可知道两件事
            - 认证公开密钥的服务器是真实有效的数字证书认证机构
            - 服务器的公开密钥是值得信赖的
        * 多数浏览器开发商发布版本时会实现在内部植入常用认证机构的公开密钥
        * __整理__
            - 第一步，服务器把自己的公开密钥登陆至数字证书认证机构
            - 第二步，数字证书认证机构用自己的私有密钥向服务器的公开密钥做数字签名并颁发公钥证书(此时服务器的公开密钥与公钥证书绑定在一起)
            - 第三步，服务器将公钥证书和服务器公钥一起发送给客户端
            - 第四步，客户端拿到数字证书认证机构为服务器颁发的公钥证书后，使用事先植入浏览器的数字证书认证机构公钥来验证公钥证书上的数字签名
            - 第五步，验证通过后，客户端将使用服务器的公钥对报文加密后发送服务器
            - 第六步，服务器用自己的私有密钥对报文解密
        * EV SSL证书：可证明组织真实性
            - 可确认对方服务器背后的运营的企业是否真实存在
            - 持有EV SSL证书的web网站浏览器地址栏处的背景色是绿色，左侧显示记录的组织名称和颁发证书的认证机构名称
        * 客户端证书：用以确认客户端
            - 证明客户端是实际存在的，并不能证明使用客户端的人是否有效
        * 自签名证书：由自认证机构颁发的证书
            - 用OpenSSL开源程序构建属于自己的认证机构，从而给自己的服务器颁发证书
            - 中级认证机构的证书可能会变成自认证证书，不同浏览器待遇不一样
    + HTTPS的安全通信机制

    + APP接口设计(加密/签名/TOKEN认证/接口版本)
        * 加密历史
            - 对称加密算法
                + 甲方选择某一种加密规则，对信息进行加密
                + 乙方使用同一规则，对信息进行解密
            - 非对称加密算法(Diffie-Hellman密钥交换算法、RSA算法)
                + 乙方生成两把密钥(公钥和私钥)。公钥是公开的，私钥是保密的。
                + 甲方获取乙方的公钥，然后用它对信息加密
                + 乙方得到加密后的信息，用私钥解密
            - RSA算法
                + 非常可靠，密钥越长，越难破解
                + 目前被破解的最长RSA密钥是768个二进制位。1024位的RSA密钥基本安全，2048位的密钥及其安全
        * 接口安全问题：
            - 请求来源是否合法
            - 请求参数是否被篡改
            - 请求是唯一的(即同样的请求，只有一次会生效)
            - 数据传输的安全性
        * 客户端请求流程
            - 请求服务端，获取RSA公钥(rsaPublicKey)以及接口密钥(key)
            - 生成AES密钥(aesKey)
            - 定义Params参数[TOKEN,PLATFORM,VERSION,MONCESTR,TIMESTAMP]加密，得到加密后的数据(encryptParams)
                + Token用户登陆凭证
                + Platform请求来源所属平台
                + Version平台版本
                + NonceStr随机字符串，用于验证请求是否重复
                + Timestamp请求时间，用于验证请求是否超时
            - 使用RSA公钥(rsaPublicKey) 对 AES密钥(aesKey)加密，得到加密后的AES密钥(encryptAesKey)
            - 将加密后的AES密钥作为HEADER参数之一，完整的HEADER参数：[KEY => encryptAesKey, VALUE => encryptParams]
            - 提取请求数据相关参数，拼接 接口密钥(key)生成签名，然后发送请求给服务端，等待响应
            - 收到服务端的响应后，使用请求时发送的AES密钥(aesKey)进行解密
        * 服务器处理流程
            - 响应客户端的请求，获取客户端传输过来的HEADER参数[KEY,VALUE]
            - 使用RSA密钥对加密后的AES密钥进行RSA解密，得到AES密钥

#确认访问用户身份的认证
#基于HTTP的功能追加协议
#构建Web内容的技术
#Web的攻击技术