#了解区块链
##加密货币就是货币
###加密货币简史
###什么是加密货币
- cryptocurrency
- 加密货币，是一种基于点对点网络(P2P网络)、没有发行机构、总量基本固定的加密电子通货
    + P2P网络：最早在使用Bit下载就是基于P2P网络的，现在很多下载工具都支持；好处就是分布式下载，没有中心服务器，要下载的文件都在用户自己的电脑上，而且下载的人越多速度就越快
    + 没有发行机构：既不是哪家公司、银行或国家控制发行的。要做到这一点，同时还要防止通货膨胀等因素，需要在编程中非常复杂的机制和规则(共识机制)来实现
    + 总量基本固定：保证加密货币价值的一种策略
    + 加密：对每一个产生电子货币本身的交易与传输的加密
    + 电子通货：是指加密货币就是货币，与黄金类似，可以自由交易，只不过是一种电子形式而已，Q币之类的就不是货币

###加密货币就是货币 
- 加密货币与法币的共同点
    + 定量：法币通常与背后的黄金或所谓的GDP挂钩，算是相对固定；加密货币，可以算作绝对的固定数量，或者少量的增发，以防止通货膨胀
    + 加密：法币是有防伪措施的；加密货币的加密技术就相当于防伪技术，每一笔交易都会被严格加密，加密货币的验证机制要远胜法币，简单、快速且更准确
    + 交易：货币也成通货，被称为一般等价物，是可以与任何商家交换，购买任何东西的，这是货币的最基本属性，加密货币也是如此

###加密货币可靠吗？
- 去中心化
    + 更确切的说应该成为分布式，是基于P2P网络的，没有一台机器是作为中心化的服务器的功能(又或者说，任何一台机器都具备中心化的服务器功能，虽为一个问题的两个极端，效果却是一样的)网络中的每一台电脑都是平等的，任何一台掉线、宕机，都不回影响整个网络继续运行
    + *这是加密货币的交易通道*，是网络的基础，可以实现无障碍交易
- 加密解密
    + 从理论上讲，加密货币的交易地址、每一笔交易等都是加密解密中的一部分，破解一个毫无意义，全部破解又相当不易，加之P2P网络节点众多，破解一个节点是没有任何价值的，所以加密货币的安全级别应该是目前最高的
    + *这是加密货币的安全保障*
- 区块链
    + 区块链是加密货币的独创，比特币的创新发明，不过区块链使用的技术却是简单的数据库技术(也可以使用文件存储)。区块链的本质就是存储在数据库里的交易数据，其结构是每一条记录都会记录前一条区块头的散列值，从而可以实现往前追溯，直到第一个创世区块
    + 这个数据库在P2P网络中是分布式存储的，每一个节点都会保存一份复制备份，每一个人都可以公开访问，查看交易记录，不仅交易双方，整个网络节点都能看到
    + *这是加密货币的信用保障*
- 共识机制
    + 工作量证明机制(PoW)、股权证明机制(PoS)、授权股权证明机制(DPoS)等。这是加密货币需要重点编码的地方，也是加密货币开发的难点所在
    + *这是加密货币的运行规则*
    
##区块链，承载人类信用的基石
###利益，现实世界的内在驱动力
###信用，决定着利益转移的方向
- 信用是交易的基础
- 信用是积累的过程
- 信用的本质是解决了信息不对称
    + 我的信息，你不知道
    + 我的信息，你知道但无法识别
    + 你知道我的信息，也可以辨别，但是无法控制

###未来趋势
###应用场景
- 转账支付
- 资金结算
- 智能合约
- 身份认证
- 电子商务
- 版本保护
- 证券交易
- 贸易金融
- 物联网和大数据

###风险提示
- 远离传销币
- 远离空壳币
- 避免操作风险
    + 选择官方钱包
    + 保护钱包私钥
    + 做好钱包备份

##共识机制，可编程的利益转移规则
###机制，左右产品走向的根源
- "机制"一词原指机器的构造和动作原理，在社会学中可以表述为"协调各个部分之间的关系以更好地发挥作用的具体运行方式"
- 实际上，区块链产品的目标就是要建立一个"无须监管的自适应经济系统"。

###PoW：工作量证明机制
- 基本原理：Proof of Work是比特币采用的共识机制，也是最早的一种机制。按劳取酬，你会获得多少报酬。在网络世界里，这里的劳动就是你为网络提供的计算服务，提供这种服务的过程就是"挖矿"
- 优点：机制本身当然很复杂，有很多细节，比如"挖矿"难度自动调整、区块奖励逐步减半等，这些因素都是基于经济学原理设置的，以吸引和鼓励更多的人参与
- 缺点
    + 算力是计算机硬件提供的，需要耗费店里，是对能源的直接消耗，与人类追求节能、清洁、环保的理念相悖。
    + 这个机制发展到尽头，算力的提供已经不再是单纯的CPU了，而是逐步发展到GPU、FPGA乃至ASIC矿机
    + 区块链产品区块奖励按照一定的周期减半，当"挖矿"的成本高于挖矿的收益时，人们"挖矿"的积极性就会降低，会有大量算力减少，网络的安全性也将进一步降低

###PoS：股权证明机制
- 基本原理：Proof of Stake机制是点点币(PPC)的创新。没有"挖矿过程"，在创世区块内写明了股权分配比例，之后通过转让、交易的方式(通常就是IPO)，逐渐分散到用户手里，并通过"利息"的方式新增货币，实现对节点的奖励。简单来说，就是一个根据用户持有货币的数量和事件，发放利息的一个制度
- 优点
    + 相对节能。不需要大量消耗电力和能源
    + 更去中心化。相对于比特币等PoW类型的区块链产品,PoS机制的区块链产品对计算机硬件基本上没有过高的要求，人人均可获得利息，不用担心算力几种导致中心化的出现，网络更加安全有保障
    + 避免紧缩。PoW机制的区块链产品，因为用户丢失等各种原因，可能会导致通货紧缩，但是PoS机制的区块链产品按一定的年利率新增货币，可以有效避免紧缩的出现，使货币保持基本稳定
- 缺点
    + 信用基础不够牢固

###DPoS：授权股权证明机制
- 基本原理：Delegated Proof of Stake是比特股(BTS)最先引入的一种机制。比特股首次提出了去中心化自治公司(DAC)的理念。比特股的目的就是用于发布DAC。这些无人控制的公司发行股份，产生利润，并将利润分配给股东。这一切的实现，不需要信任任何人，因为每件事都已经被硬编码到软件中了。通俗点讲就是，比特股创造可以盈利的公司(股份制)，股东持有这些公司的股份，公司为股东产生回报。这种机制无须"挖矿"
- 优点
    + 能耗更低，DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗将进一步降低，网络运行成本达到最低
    + 更加去中心化
    + 更快的确认速度
- 缺点
    + 投票的积极性并不高。绝大多数持股人从未参与投票
    + 对于坏节点的处理存在诸多困难。社区选举不能及时有效阻止一些破坏节点的出现，这一点对网络造成了安全隐患

###亿书对DPoS机制的改进
- 熔断机制
    + 增加反对投票功能
- 信用系统
    + 鼓励知识分享，节点和用户之间会有频繁的交互，用户对节点的反馈与好评，将是该节点信用累计的一部分
- 扩大规模
    + 鼓励去中心化应用的开发者、出版商等第三方用户自建节点，从而更好地服务于用户
- 实名认证
    + 匿名与安全是相对平衡的过程

##区块链架构设计
###基本概念
- 广义区块链
    + 目前大家单独提到区块链的时候，指的就是区块链技术，是实现了数据公开、透明、可追溯的产品的架构设计方法
    + 广义区块链技术必须包含点对点的网络设计、加密技术应用、分布式算法的实现和数据存储技术的使用这4个方面，其他的则可能设计分布式存储、机器学习、VR、物联网、大数据等
- 狭义区块链
    + 在具体的产品中谈到区块链的时候，指的可能是类似于比特币的数据存储方式，可能是数据库设计，还可能是文件形式的设计
    + 狭义区块链仅仅涉及数据存储技术、数据库或文件操作等

###架构图
- 从架构设计上来说，区块链可以简单地分为三个层次，即协议层、扩展层和应用层，其中协议层又可以分为存储层和网络层，他们相互独立但又不可分割

###协议层
- 协议层，指的是最底层的技术

###扩展层
- 这个层面类似于电脑的驱动程序，是为了让区块链产品更加实用

###应用层
- 这个层面类似于电脑中的各种软件程序，是普通人真正可以直接使用的产品，也可以理解为B/S架构的产品中的浏览器端

###编程实现
- C/C++
- Node.js/JavaScript
- Python
- Go

###知识图谱
- 基础知识
- 技术实现
- 开发环境
- 项目实践
- 开发文档

##Node.js让前端开发像子弹飞一样
###项目需求
- SACDL项目需要具备以下几个功能
    + 能够方便地读取第三方网站的API，实现功能搜索功能
    + 能够对读取的数据进行集中处理，将其方便地转化为我们所需要的信息
    + 能够通过柱状图、矩阵图、表格等图表格式，将数据可视化
    + 方便扩展，为后续添加更多图标样式或其他网站API做好准备

###技术选型
###Node.js简介
###开发步骤
- 搭建环境
- 新建工程
- 前端组件
    + bower用于管理前端包，npm用于管理后台库(包)，二者的用法十分相似
- 前端流程
    + 接收请求
    + 获取数据
    + 展示数据
- 学习API
- 数据整理
    + 模块化前端代码
    + 转化数据格式
- D3.js渲染
    + 流程
    + 渲染数据
    + 查看效果
- 代码调试
- 部署发布
    + 原理
        * Gulp的核心概念就是管道流，文件或数据就是水，gulp等各类插件就是过滤网等水处理器械。
        * 设计一个任务，就相当于建设一个管道
            - 构建管道并为管道起一个好记的名字，要使用的方法是gulp.task()
            - 管道入口方法gulp.src()
            - 每一节管道.pipe()(要用在入口和出口中间，在其中放入各种插件方法，相当于加了一层过滤网)
            - 一直流向管道出口，方法为gulp.dest()
            - 用gulp.watch监控水流变化
            - 用gulp.run综合调度各个管道的运行，最后用gulp或gulp taskname命令在命令行启动管道
    + 安装
    + 建管道
    + 插件
    + 部署

##Node.js让后台开发像前端一样简单
###需求
- 从后台读取github.com的API
- 处理读取的数据，并发送给前端

###开发
- 安装Express
- 创建简单应用
- 使用模板引擎
- 使用静态文件服务
- 后台请求github API
- 模块化重构
    + 拆分模型
    + 查分控制器
    + 拆分路由
    + 整理视图
- 测试和部署

##你必须知道的几个Node.js编码习惯
###一切都是数据流
- 概念理解
    + 流，最早是Linux环境下的概念，与之对应的方法通常是pipe，即管道方法
        * 流兼具时间和地点两个坐标，时间代表一个过程，地点代表流入、流出的位置
        * 流是一个时间上的线性过程，而非一个时间点。在一个时间段内的传输只是部分数据，若要获得完整的数据，就需要花费足够长的时间。
        * 流只能沿着构建在从发生到结束的编码位置的管道进行传输，在传输过程中，流可以被调整和改变
- 代码示例
    ```Node.js
        引用各模块
        var fs = require('fs');
        var iconv = requrie('iconv-lite');

        var rs = fs.createReadStream(test.md);
        var chunks = [],
        size = 0;

        接收数据：一段一段地接收数据
        re.on("data", function (chunk){
            chunks.push(chunk);
            size += chunk.length;
            });

        拼接数据：并转化为utf-8的编码格式，这样就能支持中文了，否则会显示乱码
        rs.on("end", function(){
            var data = Buffer.concat(chunks, size);
            varstr = iconv.decode(data, 'utf8');
            console.log(data);
            })
    ```
- 思维习惯
    + 在Node.js的世界里，无论是处理文件，还是请求远程资源，处理的都是数据流，处理方法都是如此
- 进一步拓展
    +
    因为任何流都是时间的函数，因此为了节省时间、提高效率，处理流最好的方式当然是并行处理。也就是说，每一个流最好都使用一个独立的线程而不影响其他的流。

###事事皆回调
- 概念理解
    + Node.js是单进程的(而非单线程)，只不过我们写的Javascript代码只在单线程中运行罢了，回调都放在事件轮询里处理，而事件轮询等底层代码是运行在多线程上的(即大家公认的线程池)
- 代码示例
    ```Javascript
        d3.json('resource.json',function(err,data){
            console.log("Hello, ", data);
            });
        console.log("I'm end.");


        I'm end.
        Hello, data
    ```
- 思维习惯
    + 在Node.js的世界里，到处都是回调，到处都是一部
    + I/O非阻塞
- 进一步扩展
    + async
    + promise

###异常要捕捉
- 回调太多、异步难以捕捉，是Node.js广为诟病的地方。Node.js是单进程的应用，异常如果未被正确处理，一旦抛出，就会使得整个进程死掉。而异常多发生在回调函数里，回调非常复杂的时候，异常很难定位。
- 概念理解
    + 异常通常分为两种类型
        * 失败，即正确的程序在运行时因为其他因素所导致的失败
        * 失误，Bug通常是程序员个人的问题
- 失败类型
    + 失败的原因通常是客观存在的，可以在代码里得到有效处理
        * 连接不到服务器
        * 无法解析主机名
        * 无效的用户输入
        * 请求超时
        * 服务器返回500
        * 套接字被挂起
        * 系统内存不足
    + 失误的原因多为主观因素，除非修正错误，否则永远无法被有效地处理
        * 读取一个undefined属性
        * 调用一步函数没有指定回调
        * 传递了错误参数：应该传对象的时候传递了一个字符串，或者其他内容等。
- 处理方法
    + 直接处理
    + 报告给客户端
    + 重试操作
    + 直接崩溃
    + 记录错误
- 编码实践
    + 错误的编码方式
    + 怎么传递错误
        * throw是以同步的方式传递异常的，也就是说throw与要使用throw传递错误的函数拥有相同的上下文环境
        * callback是最基础的异步传递事件的一种方式
        * 返回一个eventEmitter对象，调用者需要监听这个对象的error事件
            - 当进行一个可能会产生多个错误或多个结果的复杂操作的时候
            - 用在哪些具有复杂状态机的对象上，这些对象往往伴随着大量的异步事件
            - callback和eventEmitter可以归为一类，不要同时使用它们
    + 怎么使用它们
        * 准则：既可以同步传递错误，又可以异常传递错误，但不要同时使用
    + domain和process.on('uncaughtException')用还是不用？
        * 不鼓励使用，它们通常是作为一种保障机制，被用在整个应用级别，主要用于从未能预料到的程序错误中恢复，而不是用在具体的编码过程中
- 代码示例
    + 参数、类型及其他一些约束被清晰地文档化
    + 该函数对于所接受的参数是非常严格的，并且会在得到错误参数的时候抛出异常
    + 该函数记录了传递异常的方式
    + 返回的错误有"remoteIp"和"remotePort"字段，这样用户就可以定义自己的错误了
- Error对象属性命名约定，用如下这些名字来保持和Node.js核心和Node.js插件的一致
    + localHostname
    + localIp
    + localPort
    + remoteHostname
    + remoteIp
    + remotePort
    + path
    + srcpath
    + vdstpath
    + hostname
    + ip
    + propertyName
    + propertyValue
    + syscall
    + errno

##亿书，一个面向未来的自出版平台
###亿书是什么
- 一款写作软件，基于区块链技术

###使用场景
- 对于普通人，是一款简单的文字写作工具
- 对于博客爱好者，可以安装在服务器端，提供公开访问的功能
- 对于出版社等企业用户和开发者，它提供侧链功能，可以基于亿书强大的网络和市场使用构建发布个性化的去中心化软件，货币化一切有形或无形的资产，从中获利

###主要特点
- 用户可以用来撰写博客，将博客轻松整理成电子书，并一键发布
- 用户能轻松地将其安装在服务器上，绑定自己的域名，定制个性化页面，以供全世界浏览
- 用户能够很方便的和他人合作，类似github的代码托管
- 产品的背后，由加密货币亿书币驱动
- 基于区块链
- 提供侧链功能，帮助传统机构实现基于区块链的版权保护和流程改造功能
- 优化开发接口，方便传统博客、论坛等知识分享软件的集成使用

###核心功能
- 高性能对等网络
- 去中心化的存储和计算
- 易用易拓展的可编程侧链
- 简单易用的可视化编辑器
- 去中心化博客
- 自出版平台
- 版权注册、签名与验证
- 针对主流开源产品的官方插件
- 面向第三方开发者的开发工具包SDK

###技术架构
- 亿书完全基于Node.js平台研发，后台使用Express.js框架，前端使用Ember.js框架，客户端使用Electron框架，数据库使用SQLite，前后端统一使用JavaScript脚本语言，界面使用HTML5和CSS3

##入口程序app.js解读
###源码与类图

###解读

##一个精巧的P2P网络实现
- 区块链产品都是去中心化的应用，去中心化的基础就是P2P网络，因此P2P网络的作用和地位不言而喻，无可替代。
- 没有P2P网络的产品，不能成为区块链产品

###源码、类图与流程图
- 源码
    + peer.js
    + transport.js
    + router.js
- 类图
- 流程图

###解读


